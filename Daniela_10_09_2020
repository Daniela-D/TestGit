Status ingineresc:

Astazi am cautat informatii despre componentele schematicului.

  - MUX ( multiplexor ): la iesirea de date sunt transmise datele de intrare, in functie de valoarea semnalului de selectie:
         - daca selectie = 0, atunci la iesire sunt furnizate datele de pe intrarea 0;
         - daca selectie = 1, atunci la iesire sunt furnizate datele de pe intrarea 1;
  
  - PC ( Program Counter ): Secventa de cod pe care o are de executat un procesor se afla de cele mai multe ori 
  stocata intr-o memorie de tip ROM conectata la acesta. Pentru a decodifica si executa corect instructiunile din 
  acea memorie, procesorul trebuie sa stie tot timpul care este adresa de la care trebuie adusa o instructiune in
  etapa de fetch. Aceasta sarcina este indeplinita de registrul PC ( program counter ). 
  Rolul acestui registru este de a retine adresa de la care trebuie adusa urmatoarea instructiune din memorie. 
  Mai este numit si Instruction Pointer deoarece functioneaza exact ca un pointer: retine o adresa si ajuta procesorul 
  sa obtina datele stocate la acea adresa.
  
  - ALU ( Arithmetic Logic Unit ): este un circuit electronic digital complex care poate efectua:
          - operatii aritmetice;
          - operatii logice;
          - opreratii specifice, la nivel de bit asupra operanzilor;
    Efectuarea acestor operatii se reprezinta considerand operanzii reprezentati in baza 2 ( reprezentare binara ), granita
    intre tipurile de operatii este greu de stabilit. 
    
  - Instrucion memory: detine instructiunea in curs de executare sau decodare.
  
  - Registers: furnizeaza suport logic pentru functiile de:
          - stocare (memorare) date;
          - procesare date ( prioritate inferioara fata de functia de stocare );
    Datele memorate in registru sunt aplicate pe intrarile de date.
   1. Deplasarea datelor se realizeaza prin inserarea unor biti noi in data stocata:
          - deplasare stanga: echivalenta cu inmultirea datei stocate cu puteri ale lui 2;
          - deplasare dreapta: echivalenta cu impartirea datei stocate cu puteri ale lui 2;
          
    Permite implementarea functiilor de conversie:
          - paralel -> serie (PS);
          - serie -> paralel (SP);
          
   2. Rotirea datelor se realizeaza prin recircularea unui bit ( a unui grup de biti ):
          - rotire stanga: bitul MSB se insereaza in bitul LSB;
          - rotire dreapta: bitul LSB se insereaza in bitul MSB;
          
    Permite generarea unor semnale defazate cu nTclk.
    
   - Data memory: memoria de date in care se poate scrie rezultatul unei operatii sau din care se poate obtine
		o data pentru a efectua o operatie.
    
   - Sign-extend: este operatia de extindere a numarului de biti ai unui numar binar pastrand in acelasi timp semnlul (pozitiv/negativ) 
   si valoarea numarului. Acest lucru se realizeaza prin adaugarea de cifre la partea cea mai semnificativa a numarului. 
   Extinde un numar de 16 biti pana la 32 de biti.
   
     Alte exemple:
          - daca 6 biti sunt folositi pentru a reprezenta numarul: 00 1010 ( zecimal = 10 ) si operatia de extindere a semnului mareste
          lungimea valorii la 16 biti, atunci noua reprezentare este: 0000 0000 0000 1010. Astfel, atat valoarea cat si semnul pozitiv 
          sunt mentinute. 
          
          - daca 10 biti sunt folositi pentru a reprezenta numarul: 11 1111 0001 ( zecimal: -15, utilizand complement fata de 2 ) si operatia
          de extindere mareste lungimea valorii la 16 biti, atunci noua reprezentare este: 1111 1111 1111 0001. Astfel, se mentine semnul negativ
          si valoarea numarului original. 
          
  - Shift left 2: modifica semnalul la stanga cu 2 pozitii. 
  
       Exemplu:
         
            0001 0111 -> shift left 2: 0101 1100;
            
  - Control: primeste opcode si pe baza acestuia activeaza sau dezactiveaza componente din arhitectura.
  
  
  Tipuri de instructiuni: 
  
  1. R-type: [31:0]: 32 de biti sunt impartiti in 6 parti:
  
         - opcode(6) ( operation code ) [31:26] : determina ce parti ale procesorului vor fi utilizate pentru a executa operatia;
         - $rs(5) ( source register ) [25:21] : pe cei 5 biti pot fi reprezentate numere in intervalul numeric [0, 31];
         - $rt(5) ( source register ) [20:16] : prin numarul sau poate fi accesat un registru anume;
         - $rd(5) ( destination register ) [15:11] : registru de destinatie;
         - shamt(5) ( shift amount ) [10:6] : este utilizat in operatii de shiftare;
         - funct(6) [5:0] : este utilizat impreuna cu opcode pentru selectarea instructiunii aritmetice;
    
     Instructiunile R-type:
          -> sunt identificate printr-un opcode 0 si sunt diferentiate prin func;
          -> folosesc registri;
          -> executa operatii aritmetice cu semn, dar si fara semn;
          
     Exemplu: Siftare la stanga cu shamt 
     
          sll $rd, $rt, shamt : R[$rd] <- R[$rt] << shamt;
          
     
  2. I-type: [31:0]: 32 de biti sunt impartiti in 4 parti:
        
         - opcode(6) [31:26] ( operation code );
         - $rs(5) ( source register ) [25:21] :  adresa pentru a incarca si stoca un operand pentru instructiuni aritmetice;
         - $rt(5) ( source register ) [20:16] :  registru sursa pentru ramuri, registru destinatie pentru celelalte instructiuni de tip I;
         - $immediate(16) [15:0] : adresa la care va sari in cazul in care instructiunea este adevarata;
                                 : cei 16 biti de adresa sunt sign-extend ( extindere cu semn ) pana la 32 biti - SignExt4b(1111) = { 1 x 28, 1111 };
         
      Instructiunile I-type: sunt identificate si diferentiate prin opcode (orice numar mai mare de 3).
      
      Exemplu: 
           
           bne $rs, $rt, imm : if( R[$rs] != R[$rt] )
                                      PC <- PC + 4 + SignExt18b( {imm,00} )
      
  3. J-type: [31:0]: 32 de biti sunt impartiti in 2 parti:
  
         - opcode(6) [31:26] ( operation code );
         - address(26) [25:0] : adresa la care se face jump;
                              : cei 26 biti de adresa sunt shiftati la stanga cu 2, iar primii 4 biti din PC + 4 se vor adauga adresei shiftate la stanga
                                { PC + 4[31:28], {address, 2'b00} };
         
      Instructiunile J-type : sunt identificate si diferentiate prin opcode ( 2 si 3 ).
            
      Exemplu:
      
          j address : PC <- {(PC + 4)[31:28], address, 00}
      
  
